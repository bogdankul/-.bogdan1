АЛГОРИТМЫ СОРТИРОВКИ

СОРТИРОВКА ВЫБОРОМ (Selection Sort)
Данный метод заключается в последовательном выборе минимального (или максимального) элемента из неотсортированной части массива и перемещении его в начало (или конец). Процесс повторяется, пока все элементы не будут упорядочены.
Анализ алгоритма: Алгоритм строится на двух вложенных циклах:
Внешний цикл (for (int i = 0; i < n - 1; ++i)): последовательно перебирает элементы с первого до предпоследнего.
Внутренний цикл (for (int j = i + 1; j < n; ++j)): находит наименьший элемент в оставшейся правой части.
После завершения внутреннего цикла найденный минимальный элемент меняется местами с текущим элементом внешнего цикла с помощью std::swap(). Временная сложность: O(n²) Причина: наличие двух вложенных циклов, каждый из которых в худшем случае может выполняться порядка n раз, что дает квадратичную зависимость.

СОРТИРОВКА ОБМЕНОМ (Bubble Sort)
В этом алгоритме массив многократно просматривается, при этом соседние элементы сравниваются и меняются местами, если они стоят в неправильном порядке. Проходы продолжаются до тех пор, пока массив не будет полностью отсортирован.
Анализ алгоритма:
Внешний цикл определяет количество проходов по массиву; на каждом проходе следующий по величине элемент "всплывает" на свою позицию в конце.
Внутренний цикл попарно сравнивает и при необходимости обменивает соседние элементы. С каждым проходом длина неотсортированной части уменьшается.
Временная сложность: O(n²)
Причина: в худшем случае требуется выполнить около n*(n-1)/2 операций сравнения и обмена, аналогично сортировке выбором.

СОРТИРОВКА ВСТАВКАМИ (Insertion Sort)
Алгоритм строит отсортированную последовательность, поочередно вставляя каждый новый элемент в подходящую позицию среди уже упорядоченных. Первый элемент считается изначально отсортированным.
Анализ алгоритма:
Основной цикл (for i in range(1, len(arr))) обрабатывает элементы, начиная со второго.
Внутренний цикл (while j >= 0 and key < arr[j]) сдвигает элементы отсортированной части вправо, чтобы освободить место для вставки.
После нахождения правильной позиции текущий элемент (key) помещается в массив (arr[j + 1] = key).
Временная сложность: O(n²)
Причина: в худшем случае количество операций (сравнений и сдвигов) описывается суммой арифметической прогрессии 1 + 2 + 3 + ... + (n-1) = n*(n-1)/2.

СОРТИРОВКА СЛИЯНИЕМ (Merge Sort)
Этот алгоритм разделяет исходный массив на две половины, рекурсивно сортирует каждую из них, а затем объединяет (сливает) их в один отсортированный массив.
Анализ алгоритма:
Рекурсивная функция mergeSort(vector& arr, int left, int right) отвечает за разделение массива и рекурсивную сортировку половин.
Функция слияния merge(vector& arr, int left, int mid, int right) объединяет два отсортированных подмассива. Для этого используются временные массивы L и R, из которых элементы переносятся обратно в основной массив в правильном порядке.
Временная сложность: O(n log n)
Причина: на каждом из log₂n уровней рекурсии выполняется линейное количество операций O(n), что в сумме дает O(n log n).

СОРТИРОВКА ШЕЛЛА (Shell Sort)
Улучшенная версия сортировки вставками, которая сортирует элементы, отстоящие друг от друга на некотором расстоянии (шаге). Шаг постепенно уменьшается до единицы.
Анализ алгоритма:
Внешний цикл (while gap > 0) контролирует уменьшение шага.
Внутренний цикл (for i in range(gap, len(arr))) проходит по элементам, начиная с индекса, равного текущему шагу.
Подцикл (while j >= gap and arr[j-gap] > temp) осуществляет сравнение и сдвиг элементов на расстоянии gap, после чего вставляет текущий элемент (temp) в найденную позицию.
Временная сложность: O(n²)
Причина: несмотря на то, что внутренние циклы выполняются меньше n раз, в худшем случае сложность остается квадратичной.

БЫСТРАЯ СОРТИРОВКА (Quick Sort)
Алгоритм выбирает опорный элемент, разделяет массив на элементы меньше опорного, равные ему и больше, после чего рекурсивно сортирует подмассивы меньших и больших элементов.
Анализ алгоритма:
Опорный элемент может быть выбран различными способами, например, как средний элемент (pivot = arr[len(arr) // 2]).
Массив разделяется на три части: left (элементы меньше опорного), middle (равные опорному), right (большие опорного).
Рекурсивная сортировка применяется к left и right, после чего результаты объединяются: return quick_sort(left) + middle + quick_sort(right).
Временная сложность: O(n²)
Причина: в неудачном сценарии (например, при уже отсортированном массиве) выбор опорного элемента может приводить к квадратичной сложности.

ПИРАМИДАЛЬНАЯ СОРТИРОВКА (Heap Sort)
Алгоритм основан на преобразовании массива в специальную структуру данных — кучу (heap), с последующим извлечением максимальных элементов и восстановлением свойств кучи.
Анализ алгоритма:
Функция heapify (vector& arr, int n, int root) обеспечивает выполнение основного свойства кучи (родитель больше потомков) для поддерева с корнем в точке root.
Основная функция heapSort сначала строит из массива max-кучу, затем последовательно извлекает корневой (максимальный) элемент, помещает его в конец и заново упорядочивает кучу.
Временная сложность: O(n log n)
Причина: операция упорядочивания в куче (heapify) имеет сложность O(log n) и выполняется n раз.

АЛГОРИТМЫ ПОИСКА

ПОСЛЕДОВАТЕЛЬНЫЙ (ЛИНЕЙНЫЙ) ПОИСК
Самый простой алгоритм, который последовательно проверяет каждый элемент массива до тех пор, пока не будет найден искомый элемент или не будет достигнут конец массива.
Анализ алгоритма: Функция linear_search(arr, target) организует цикл for index, value in enumerate(arr), в котором сравнивает каждый value с target. При совпадении возвращается index.
Временная сложность: O(n)
Причина: в худшем случае требуется проверить все n элементов массива.

БИНАРНЫЙ (ДВОИЧНЫЙ) ПОИСК
Применяется исключительно к отсортированным массивам. На каждом шаге алгоритм сравнивает искомый элемент с элементом в середине текущего диапазона, сокращая область поиска вдвое.
Анализ алгоритма: В функции binary_search(arr, target) в цикле while low <= high вычисляется средний индекс mid = (low + high) // 2. Если target меньше arr[mid], поиск продолжается в левой половине (high = mid - 1), если больше — в правой (low = mid + 1).
Временная сложность: O(log n)
Причина: на каждом шаге размер области поиска уменьшается в два раза.

ИНТЕРПОЛЯЦИОННЫЙ ПОИСК
Модификация бинарного поиска, эффективная для отсортированных массивов с равномерным распределением данных. Позиция для сравнения вычисляется по интерполяционной формуле.
Анализ алгоритма: Функция interpolationSearch(int arr[], int n, int target) в цикле while вычисляет предполагаемую позицию pos по формуле: pos = low + (((double)(high - low) / (arr[high] - arr[low])) * (target - arr[low])). Это позволяет приблизительно угадать место искомого элемента.
Временная сложность: O(n)
Причина: при неравномерном распределении данных алгоритм может деградировать до линейного поиска.

ПОИСК ПО ФИБОНАЧЧИ (Fibonacci Search)
Еще один алгоритм для отсортированных массивов, который использует числа Фибоначчи для определения индексов сравнения.
Анализ алгоритма: Сначала генерируется последовательность Фибоначчи (fib_M, fib_m_minus_1, fib_m_minus_2), пока fib_M не превысит длину массива. Далее в цикле while fib_M > 1 вычисляется индекс i = min(offset + fib_m_minus_2, len(arr)-1) для сравнения. В зависимости от результата корректируются переменные Фибоначчи и смещение offset.
Временная сложность: O(log n)
Причина: на каждом шаге размер области поиска сокращается, асимптотически аналогично бинарному поиску.

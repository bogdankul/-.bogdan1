def set_cover(universe, subsets):
    """
    Жадный алгоритм для задачи покрытия множества.
    
    Args:
        universe: множество всех элементов, которые нужно покрыть
        subsets: список подмножеств (каждое подмножество - множество элементов)
    
    Returns:
        list: список подмножеств, образующих покрытие
    """
    # СОЗДАЕМ КОПИИ ДАННЫХ ДЛЯ БЕЗОПАСНОЙ РАБОТЫ
    # Множество еще не покрытых элементов (изначально = всему универсуму)
    uncovered = set(universe)
    # Преобразуем все подмножества в множества для гарантированной работы операций
    subsets = [set(subset) for subset in subsets]
    # Список для хранения результата - выбранных подмножеств
    result = []
    
    # ОСНОВНОЙ ЦИКЛ АЛГОРИТМА
    # Продолжаем, пока есть непокрытые элементы
    while uncovered:
        # ПЕРЕМЕННЫЕ ДЛЯ ПОИСКА ЛУЧШЕГО ПОДМНОЖЕСТВА
        best_subset = None    # Здесь будем хранить лучшее подмножество
        best_covered = set()  # Здесь - элементы, которые оно покроет
        
        # ПЕРЕБОР ВСЕХ ПОДМНОЖЕСТВ ДЛЯ ВЫБОРА ЛУЧШЕГО
        for subset in subsets:
            # НАХОДИМ ПЕРЕСЕЧЕНИЕ: какие элементы этого подмножества еще не покрыты
            # Операция & (intersection) возвращает общие элементы
            current_covered = subset & uncovered
            
            # СРАВНИВАЕМ С ТЕКУЩИМ ЛУЧШИМ РЕЗУЛЬТАТОМ
            # Если это подмножество покрывает больше новых элементов, чем предыдущий лучший
            if len(current_covered) > len(best_covered):
                # ОБНОВЛЯЕМ ЛУЧШЕЕ ПОДМНОЖЕСТВО
                best_subset = subset
                best_covered = current_covered
        
        # ПРОВЕРКА: нашли ли мы подходящее подмножество
        if best_subset:
            # ДОБАВЛЯЕМ ЛУЧШЕЕ ПОДМНОЖЕСТВО В РЕЗУЛЬТАТ
            result.append(best_subset)
            # УДАЛЯЕМ ПОКРЫТЫЕ ЭЛЕМЕНТЫ ИЗ МНОЖЕСТВА НЕПОКРЫТЫХ
            # Операция -= (difference update) удаляет элементы best_covered из uncovered
            uncovered -= best_covered
        else:
            # ЕСЛИ НЕ НАШЛИ ПОДХОДЯЩЕГО ПОДМНОЖЕСТВА
            # Это может случиться, если невозможно покрыть все элементы
            # Выходим из цикла, чтобы избежать бесконечного выполнения
            break
    
    # ВОЗВРАЩАЕМ РЕЗУЛЬТАТ - СПИСОК ВЫБРАННЫХ ПОДМНОЖЕСТВ
    return result

# ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ С ПОЯСНЕНИЯМИ
if __name__ == "__main__":
    print("=== ПРИМЕР 1 ===")
    # ОПРЕДЕЛЯЕМ ИСХОДНЫЕ ДАННЫЕ
    universe1 = {1, 2, 3, 4, 5}  # Все элементы, которые нужно покрыть
    subsets1 = [                  # Доступные подмножества
        {1, 2, 3},  # Подмножество 1
        {2, 4},     # Подмножество 2  
        {3, 4},     # Подмножество 3
        {4, 5},     # Подмножество 4
        {1, 3}      # Подмножество 5
    ]
    
    # ВЫЗЫВАЕМ ФУНКЦИЮ ПОКРЫТИЯ
    cover1 = set_cover(universe1, subsets1)
    
    # ВЫВОДИМ РЕЗУЛЬТАТЫ С ПОЯСНЕНИЯМИ
    print("Все элементы для покрытия:", universe1)
    print("Выбранные подмножества для покрытия:", cover1)
    
    # ПРОВЕРЯЕМ РЕЗУЛЬТАТ: объединяем все выбранные подмножества
    covered_elements = set().union(*cover1) if cover1 else set()
    print("Фактически покрытые элементы:", covered_elements)
    print("Количество использованных подмножеств:", len(cover1))
    
    # ПРОВЕРКА КОРРЕКТНОСТИ
    if covered_elements == universe1:
        print("✓ ВСЕ ЭЛЕМЕНТЫ УСПЕШНО ПОКРЫТЫ!")
    else:
        print("⚠ НЕ ВСЕ ЭЛЕМЕНТЫ ПОКРЫТЫ!")
        print("Не покрытые элементы:", universe1 - covered_elements)
    
    print("\n" + "="*50 + "\n")
    
    print("=== ПРИМЕР 2 (БОЛЬШЕ ЭЛЕМЕНТОВ) ===")
    # ВТОРОЙ ПРИМЕР С БОЛЬШИМ УНИВЕРСУМОМ
    universe2 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    subsets2 = [
        {1, 2, 3, 4, 5},  # Большое подмножество - будет выбрано первым
        {4, 5, 6, 7},     # Среднее подмножество
        {6, 7, 8, 9, 10}, # Другое большое подмножество - будет выбрано вторым
        {1, 8, 9},        # Маленькое подмножество
        {2, 3, 10}        # Маленькое подмножество
    ]
    
    cover2 = set_cover(universe2, subsets2)
    
    print("Все элементы для покрытия:", universe2)
    print("Выбранные подмножества:", cover2)
    
    covered_elements2 = set().union(*cover2) if cover2 else set()
    print("Покрытые элементы:", covered_elements2)
    print("Количество подмножеств:", len(cover2))
    
    if covered_elements2 == universe2:
        print("✓ ВСЕ ЭЛЕМЕНТЫ УСПЕШНО ПОКРЫТЫ!")
    else:
        print("⚠ НЕ ВСЕ ЭЛЕМЕНТЫ ПОКРЫТЫ!")
        print("Не покрытые элементы:", universe2 - covered_elements2)
1) Вариант 9 - создание рекурсивной функции для проверки, отсортирован массив или нет
2) Пояснение алгоритма: 
	1. arr — входной массив для проверки;
	   index — текущий индекс элемента (по умолчанию 0, начало массива).
	2. Базовый случай рекурсии (if index >= len(arr) - 1)
	   Условие срабатывает, когда:
	   массив пуст (len(arr) == 0 → index >= -1); в массиве 1 элемент (len(arr) == 1 → index >= 0);
	   мы проверили все пары и дошли до предпоследнего элемента.
	   В этих случаях массив считается отсортированным → возвращаем True.
	3. Проверка пары элементов (if arr[index] <= arr[index + 1])
	   Сравниваем элемент по текущему индексу с следующим. 
           Если порядок соблюдён (<=), рекурсивно проверяем следующую пару.
	   Если порядок нарушен (>), сразу возвращаем False (дальшая проверка не нужна).
	4. Рекурсивный вызов (return is_sorted(arr, index + 1))
	   Передаём тот же массив и следующий индекс (index + 1).
	   Функция повторяет логику для новой пары элементов.
	5. Рекурсивный вызов (return is_sorted(arr, index + 1))
	   Передаём тот же массив и следующий индекс (index + 1).
	   Функция повторяет логику для новой пары элементов.
	Пример: отсортированный массив [2, 5, 7, 9]
	is_sorted([2, 5, 7, 9], index=0)
	0 >= 3? → нет
	2 <= 5? → да
	вызов: is_sorted(..., index=1)
3) Временная сложность: O(n)
4) Объяснение временной сложности: 
	Худший случай (массив отсортирован):
	Функция выполнит n − 1 сравнений (для массива длины n).
	Глубина рекурсии — также n − 1 вызовов.
	Каждая операция (сравнение + рекурсивный вызов) выполняется за O(1).
	Итого: T(n) = c · (n − 1) → O(n).
	Лучший случай (первый элемент > второго):
	Одно сравнение → O(1).
	В самом плохом случае (когда массив действительно отсортирован) мы пройдём все пары — то есть сделаем примерно n−1 шагов, где n — длина массива. Это линейное время: чем больше чисел, тем дольше, но ровно пропорционально.
	В лучшем случае (если первые два числа уже нарушают порядок) мы сделаем всего один шаг — это очень быстро
	Память тратится на «запоминание» каждого шага (из‑за рекурсии), поэтому тоже получается пропорционально длине массива.
5) Ответ на контрольный вопрос: Ответ на контрольный вопрос номер 5: Стратегия «разделяй и властвуй» предполагает: разделить исходную задачу на несколько подзадач, рекурсивно их решить, а затем объединить частичные решения. Сортировка слиянием (Merge Sort) — канонический пример: она рекурсивно делит массив пополам, сортирует полученные половины и затем линейно сливает две отсортированные последовательности в одну. Основные этапы Merge Sort: Divide: разбить массив на две части, пока подмассивы не станут единичного размера, что формирует базовые случаи рекурсивного процесса. Conquer: рекурсивно отсортировать левую и правую половины с применением той же процедуры на меньших входах. Combine: выполнить слияние двух отсортированных подмассивов в один, проходя их линейно и выбирая наименьший из головных элементов.

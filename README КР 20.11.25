# Пункт 1) Вариант 4. Жадный алгоритм: покрытие множества
Условие. Дано семейство подмножеств. Выбрать минимальное число подмножеств,
покрывающих все элементы.
Алгоритм: жадный выбор подмножества с максимальным числом новых элементов

# Пункт 2)
ШАГ 1: ИНИЦИАЛИЗАЦИЯ ПЕРЕМЕННЫХ
Дополнение: Мы создаем копии данных, чтобы не изменять оригинальные входные параметры. Это важно для многократного использования функции с теми же данными. Множества используются потому что операции с ними выполняются за O(1) в среднем случае.

uncovered = set(universe)           # Создаем копию универсума как непокрытых элементов
subsets = [set(subset) for subset in subsets]  # Преобразуем подмножества в множества
result = []                         # Пустой список для результата

ШАГ 2: ЗАПУСК ОСНОВНОГО ЦИКЛА
Дополнение: Условие while uncovered эквивалентно while len(uncovered) > 0. Цикл гарантированно завершится, так как на каждой итерации мы уменьшаем количество непокрытых элементов, и в худшем случае за m итераций (где m - количество подмножеств).

while uncovered:  # Пока есть непокрытые элементы

ШАГ 3: ИНИЦИАЛИЗАЦИЯ ПОИСКА ЛУЧШЕГО ПОДМНОЖЕСТВА
Дополнение: Мы инициализируем best_covered как пустое множество, что соответствует 0 покрытых элементов. Это гарантирует, что мы выберем любое подмножество, которое покрывает хотя бы 1 новый элемент.

best_subset = None
best_covered = set()

ШАГ 4: ПЕРЕБОР ВСЕХ ПОДМНОЖЕСТВ
Дополнение: Операция & (пересечение) выполняется очень быстро для множеств. Мы перебираем ВСЕ подмножества на каждой итерации, даже те, которые уже были выбраны ранее. Это не оптимально, но гарантирует простоту реализации.

for subset in subsets:
    current_covered = subset & uncovered

ШАГ 5: СРАВНЕНИЕ И ВЫБОР ЛУЧШЕГО
Дополнение: Критерий выбора - только количество новых элементов. Мы не учитываем размер подмножества или другие метрики. Если несколько подмножеств покрывают одинаковое количество новых элементов, будет выбрано первое из них.

if len(current_covered) > len(best_covered):
    best_subset = subset
    best_covered = current_covered

ШАГ 6: ПРОДОЛЖЕНИЕ ПЕРЕБОРА ДРУГИХ ПОДМНОЖЕСТВ
Дополнение: Алгоритм продолжает проверять все оставшиеся подмножества, даже после нахождения хорошего кандидата. Это гарантирует, что мы не пропустим лучшее решение, но увеличивает время выполнения.

for subset in subsets:
    current_covered = subset & uncovered

ШАГ 7: ДОБАВЛЕНИЕ ЛУЧШЕГО ПОДМНОЖЕСТВА В РЕЗУЛЬТАТ
Дополнение: Операция -= (разность) модифицирует множество на месте. Важно, что мы удаляем только те элементы, которые были покрыты выбранным подмножеством, а не все элементы этого подмножества.

if best_subset:
    result.append(best_subset)
    uncovered -= best_covered

ШАГ 8: ВТОРАЯ ИТЕРАЦИЯ ЦИКЛА
Дополнение: На второй итерации подмножество {1,2,3} уже не рассматривается как полезное, так как все его элементы уже покрыты. Это показывает, как алгоритм адаптируется к текущему состоянию покрытия.

while uncovered:  # uncovered = {4, 5} - цикл продолжается

ШАГ 9: ЗАВЕРШЕНИЕ ЦИКЛА
Дополнение: Алгоритм завершается когда либо все элементы покрыты, либо когда больше нет подмножеств, покрывающих новые элементы (в случае невозможности полного покрытия).

while uncovered:  # uncovered = set() - цикл завершается

ШАГ 10: ВОЗВРАТ РЕЗУЛЬТАТА
Дополнение: Возвращаемый результат может не быть минимально возможным, но гарантируется, что он не более чем в O(log n) раз хуже оптимального решения.

return result

# Пункт 3) Временная сложность - O(m²·n)

# Пункт 4) Объяснение временной сложности: 

КАК РАБОТАЕТ АЛГОРИТМ ШАГ ЗА ШАГОМ:

ПЕРВЫЙ УРОВЕНЬ: Главный цикл while

Алгоритм делает k шагов - столько подмножеств мы в итоге выберем

На каждом шаге он покрывает хотя бы один новый элемент

В худшем случае: если каждое подмножество покрывает только 1 новый элемент, то k = m

ВТОРОЙ УРОВЕНЬ: На каждом шаге мы перебираем ВСЕ подмножества

Даже те, которые уже бесполезны

Даже те, которые мы уже проверяли много раз

Каждый раз: m операций

ТРЕТИЙ УРОВЕНЬ: Для каждого подмножества делаем операции с множествами

Пересечение множеств: сравниваем элементы

В худшем случае: n операций (если множества большие)

ПЕРЕМНОЖАЕМ ВСЕ УРОВНИ:

k шагов × m подмножеств на каждом шаге × n операций для каждого подмножества

ФОРМУЛА: O(k × m × n)

В САМОМ ХУДШЕМ СЛУЧАЕ: k = m → O(m × m × n) = O(m²·n)

# Пункт 5) Ответ на контрольный вопрос №5

ЧТО ТАКОЕ ВЕРШИННОЕ ПОКРЫТИЕ?
Представьте граф как набор точек (вершин), соединённых линиями (рёбрами). Вершинное покрытие — это такой набор точек, что каждая линия касается хотя бы одной из выбранных точек.

Задача: найти наименьшее количество точек, чтобы покрыть все линии.

ПРОСТОЙ АЛГОРИТМ
Находим "независимые" линии — такие, которые не имеют общих концов (это называется паросочетанием)

Берём ВСЕ концы этих линий в наше покрытие

ПОЧЕМУ ЭТО РАБОТАЕТ В 2 РАЗА ХУЖЕ ОПТИМАЛЬНОГО?
ПЕРВОЕ НАБЛЮДЕНИЕ: Сколько точек мы взяли?

У каждой линии 2 конца

Если у нас K линий в паросочетании, то точек мы взяли 2K

ВТОРОЕ НАБЛЮДЕНИЕ: Сколько точек ДОЛЖЕН взять любой алгоритм?
Каждую линию из паросочетания должен покрывать хотя бы один свой конец
Поскольку линии не пересекаются, для K линий нужно как минимум K точек
Даже оптимальный алгоритм не может обойтись меньшим числом

СРАВНИВАЕМ:

Наш алгоритм взял: 2K точек
Оптимальный взял: как минимум K точек
Значит, мы взяли не более чем в 2 раза больше оптимального!

Жадный алгоритм по степеням — плохая аппроксимация (Ω(log n))
Алгоритм на основе паросочетания — 2-аппроксимация

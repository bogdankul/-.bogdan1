Вариант 5.
Покрытие множеств с жадным алгоритмом

Определение самого алгоритма:

Жадный алгоритм для задачи покрытия множеств — это итеративный аппроксимационный алгоритм, который на каждом шаге выбирает локально оптимальное множество, максимизирующее количество вновь покрываемых элементов, с целью построения покрытия всего универсума.

Ключевые свойства:

1) Детерминированность: При одинаковых входных данных всегда дает одинаковый результат

2) Монотонность: Количество непокрытых элементов строго убывает

3) Корректность: Гарантированно находит покрытие (если оно существует)

4) Аппроксимация: Дает решение в H(max|Sᵢ|) раз хуже оптимального, где H(n) — n-ное гармоническое число

Жадный критерий оптимальности: Алгоритм не дает точного решения, но гарантирует, что найденное покрытие будет не более чем в O(log m) раз больше минимального возможного покрытия.

Этот алгоритм является классическим примером жадной стратегии в комбинаторной оптимизации и широко применяется благодаря своей простоте и хорошим аппроксимационным свойствам.

Анализ алгоритма:

Шаг 1: Подготовка и инициализация
Первым делом алгоритм подготавливает все необходимые структуры данных. Мы создаем копию универсума для отслеживания непокрытых элементов, копируем доступные множества и инициализируем пустой список для результирующего покрытия:

uncovered = set(universe)           # Копируем универсум
remaining_subsets = dict(subsets)   # Копируем множества
selected_sets = []                  # Пустой список для результата

Шаг 2: Главный цикл - проверка условия продолжения
Алгоритм входит в основной цикл, который будет выполняться до тех пор, пока есть непокрытые элементы. На каждом шаге мы выводим текущее состояние непокрытых элементов.

while uncovered:
    print(f"   Непокрытые элементы: {uncovered}")

Шаг 3: Поиск лучшего кандидата
Теперь алгоритм перебирает все доступные множества и для каждого вычисляет, сколько новых (еще непокрытых) элементов оно может покрыть. Это ключевой момент жадной стратегии - мы ищем максимальную немедленную выгоду.

for name, subset in remaining_subsets.items():
    coverage = len(subset & uncovered)  # Пересечение с непокрытыми
    coverage_elements = subset & uncovered

Шаг 4: Сравнение и выбор оптимального множества
Алгоритм сравнивает все кандидаты и выбирает тот, который покрывает наибольшее количество непокрытых элементов. Если находится несколько кандидатов с одинаковым покрытием, выбирается первый из них

if coverage > best_set_coverage:
    best_set_name = name
    best_set_coverage = coverage
    best_set_elements = coverage_elements

Шаг 5: Обновление состояния алгоритма
После выбора оптимального множества алгоритм выполняет три важных действия: добавляет выбранное множество в результат, удаляет покрытые элементы из непокрытых и убирает использованное множество из доступных кандидатов.

selected_sets.append(best_set_name)                    # Добавляем в результат
uncovered -= remaining_subsets[best_set_name]         # Удаляем покрытые элементы
del remaining_subsets[best_set_name]                  # Удаляем использованное множество

Шаг 6: Информационный вывод и переход к следующей итерации
Алгоритм выводит информацию о сделанном выборе и переходит к следующему шагу. Этот процесс повторяется до полного покрытия универсума.

print(f"   ВЫБРАНО: {best_set_name}")
print(f"   Покрытые на этом шаге: {best_set_elements}")
step += 1  # Переход к следующему шагу

Шаг 7: Завершение работы
Когда все элементы покрыты (uncovered становится пустым), алгоритм выходит из цикла, выводит финальный результат и возвращает найденное покрытие.

print(f"АЛГОРИТМ ЗАВЕРШЕН")
print(f"Финальное покрытие: {selected_sets}")
return selected_sets

Оценка временной сложности
Итоговая временная сложность:  O(m × n²)

Почему временная сложность именно такая
Внешний цикл while uncovered выполняется максимум k раз, где k - количество множеств в финальном покрытии. В худшем случае k = n, когда нам нужно выбрать все множества. На каждой итерации внешнего цикла мы перебираем все доступные множества. В начале их n, потом n-1, n-2 и т.д. В среднем это O(n) операций на каждую итерацию внешнего цикла. Для каждого множества мы вычисляем пересечение subset & uncovered. Операция пересечения множеств в Python имеет сложность O(min(len(subset), len(uncovered))). В худшем случае это O(m).
Умножаем все вместе:

Внешний цикл: O(k) итераций
Внутренний цикл: O(n) операций на итерацию
Операции внутри: O(m) на каждую операцию

Итого: O(k × n × m)

Поскольку в худшем случае k = n, получаем O(n² × m)

Ответ на контрольный вопрос: 
16. Что такое оператор соседства в контексте эвристических алгоритмов? Приведите примеры.
Оператор соседства(Neighborhood Operator или Move Operator) — это ключевой компонент эвристических алгоритмов (таких как локальный поиск, имитация отжига, поиск с табу, муравьиные колонии и генетические алгоритмы), который определяет, как можно преобразовать текущее решение задачи для получения нового, "соседнего" решения. Если представить множество всех возможных решений как "ландшафт", то оператор соседства — это правило, которое из любой точки этого ландшафта показывает, в какие соседние точки можно перейти за один шаг.

Примеры операторов соседства
Задача коммивояжера (TSP - Traveling Salesman Problem) Цель: Найти кратчайший маршрут, проходящий через все города по одному разу и возвращающийся в исходный город.
Задача о рюкзаке (Knapsack Problem) Цель: Выбрать набор предметов с максимальной суммарной стоимостью, не превышая вместимость рюкзака.
Задачи составления расписания (Scheduling) Цель: Назначить задания на ресурсы (станки, процессоры) с оптимизацией некоторого критерия (например, общего времени выполнения).
В современных метаэвристиках часто используется не один, а несколько операторов соседства, которые применяются адаптивно в зависимости от ситуации. Оператор соседства — это правило перехода** от одного решения к другому.
